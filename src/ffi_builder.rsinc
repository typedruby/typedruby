// This file is autogenerated by script/mkbuilder
// DO NOT MODIFY
#[repr(C)]
pub struct BuilderInterface {
	pub accessible: unsafe extern "C" fn(builder: *mut Builder, node: *mut Rc<Node>) -> *mut Rc<Node>,
	pub alias: unsafe extern "C" fn(builder: *mut Builder, alias: *const TokenPtr, to: *mut Rc<Node>, from: *mut Rc<Node>) -> *mut Rc<Node>,
	pub arg: unsafe extern "C" fn(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node>,
	pub args: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, args: *mut NodeListPtr, end: *const TokenPtr, check_args: bool) -> *mut Rc<Node>,
	pub array: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, elements: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub assign: unsafe extern "C" fn(builder: *mut Builder, lhs: *mut Rc<Node>, eql: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node>,
	pub assignable: unsafe extern "C" fn(builder: *mut Builder, node: *mut Rc<Node>) -> *mut Rc<Node>,
	pub associate: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, pairs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub attr_asgn: unsafe extern "C" fn(builder: *mut Builder, receiver: *mut Rc<Node>, dot: *const TokenPtr, selector: *const TokenPtr) -> *mut Rc<Node>,
	pub back_ref: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub begin: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub begin_body: unsafe extern "C" fn(builder: *mut Builder, body: *mut Rc<Node>, rescue_bodies: *mut NodeListPtr, else_tok: *const TokenPtr, else_: *mut Rc<Node>, ensure_tok: *const TokenPtr, ensure: *mut Rc<Node>) -> *mut Rc<Node>,
	pub begin_keyword: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub binary_op: unsafe extern "C" fn(builder: *mut Builder, receiver: *mut Rc<Node>, oper: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub block: unsafe extern "C" fn(builder: *mut Builder, method_call: *mut Rc<Node>, begin: *const TokenPtr, args: *mut Rc<Node>, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub block_pass: unsafe extern "C" fn(builder: *mut Builder, amper: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub blockarg: unsafe extern "C" fn(builder: *mut Builder, amper: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node>,
	pub call_lambda: unsafe extern "C" fn(builder: *mut Builder, lambda: *const TokenPtr) -> *mut Rc<Node>,
	pub call_method: unsafe extern "C" fn(builder: *mut Builder, receiver: *mut Rc<Node>, dot: *const TokenPtr, selector: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node>,
	pub case_: unsafe extern "C" fn(builder: *mut Builder, case_: *const TokenPtr, expr: *mut Rc<Node>, when_bodies: *mut NodeListPtr, else_tok: *const TokenPtr, else_body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub character: unsafe extern "C" fn(builder: *mut Builder, char_: *const TokenPtr) -> *mut Rc<Node>,
	pub complex: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub compstmt: unsafe extern "C" fn(builder: *mut Builder, node: *mut NodeListPtr) -> *mut Rc<Node>,
	pub condition: unsafe extern "C" fn(builder: *mut Builder, cond_tok: *const TokenPtr, cond: *mut Rc<Node>, then: *const TokenPtr, if_true: *mut Rc<Node>, else_: *const TokenPtr, if_false: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub condition_mod: unsafe extern "C" fn(builder: *mut Builder, if_true: *mut Rc<Node>, if_false: *mut Rc<Node>, cond: *mut Rc<Node>) -> *mut Rc<Node>,
	pub const_: unsafe extern "C" fn(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node>,
	pub const_fetch: unsafe extern "C" fn(builder: *mut Builder, scope: *mut Rc<Node>, colon: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node>,
	pub const_global: unsafe extern "C" fn(builder: *mut Builder, colon: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node>,
	pub const_op_assignable: unsafe extern "C" fn(builder: *mut Builder, node: *mut Rc<Node>) -> *mut Rc<Node>,
	pub cvar: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub dedent_string: unsafe extern "C" fn(builder: *mut Builder, node: *mut Rc<Node>, dedent_level: size_t) -> *mut Rc<Node>,
	pub def_class: unsafe extern "C" fn(builder: *mut Builder, class_: *const TokenPtr, name: *mut Rc<Node>, lt_: *const TokenPtr, superclass: *mut Rc<Node>, body: *mut Rc<Node>, end_: *const TokenPtr) -> *mut Rc<Node>,
	pub def_method: unsafe extern "C" fn(builder: *mut Builder, def: *const TokenPtr, name: *const TokenPtr, args: *mut Rc<Node>, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub def_module: unsafe extern "C" fn(builder: *mut Builder, module: *const TokenPtr, name: *mut Rc<Node>, body: *mut Rc<Node>, end_: *const TokenPtr) -> *mut Rc<Node>,
	pub def_sclass: unsafe extern "C" fn(builder: *mut Builder, class_: *const TokenPtr, lshft_: *const TokenPtr, expr: *mut Rc<Node>, body: *mut Rc<Node>, end_: *const TokenPtr) -> *mut Rc<Node>,
	pub def_singleton: unsafe extern "C" fn(builder: *mut Builder, def: *const TokenPtr, definee: *mut Rc<Node>, dot: *const TokenPtr, name: *const TokenPtr, args: *mut Rc<Node>, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub encoding_literal: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub false_: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub file_literal: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub float_: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub float_complex: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub for_: unsafe extern "C" fn(builder: *mut Builder, for_: *const TokenPtr, iterator: *mut Rc<Node>, in_: *const TokenPtr, iteratee: *mut Rc<Node>, do_: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub gvar: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub ident: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub index: unsafe extern "C" fn(builder: *mut Builder, receiver: *mut Rc<Node>, lbrack: *const TokenPtr, indexes: *mut NodeListPtr, rbrack: *const TokenPtr) -> *mut Rc<Node>,
	pub index_asgn: unsafe extern "C" fn(builder: *mut Builder, receiver: *mut Rc<Node>, lbrack: *const TokenPtr, indexes: *mut NodeListPtr, rbrack: *const TokenPtr) -> *mut Rc<Node>,
	pub integer: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub ivar: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_break: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_defined: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub keyword_next: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_redo: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_retry: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_return: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_super: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_yield: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node>,
	pub keyword_zsuper: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr) -> *mut Rc<Node>,
	pub kwarg: unsafe extern "C" fn(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node>,
	pub kwoptarg: unsafe extern "C" fn(builder: *mut Builder, name: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node>,
	pub kwrestarg: unsafe extern "C" fn(builder: *mut Builder, dstar: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node>,
	pub kwsplat: unsafe extern "C" fn(builder: *mut Builder, dstar: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub line_literal: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub logical_and: unsafe extern "C" fn(builder: *mut Builder, lhs: *mut Rc<Node>, op: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node>,
	pub logical_or: unsafe extern "C" fn(builder: *mut Builder, lhs: *mut Rc<Node>, op: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node>,
	pub loop_until: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, cond: *mut Rc<Node>, do_: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub loop_until_mod: unsafe extern "C" fn(builder: *mut Builder, body: *mut Rc<Node>, cond: *mut Rc<Node>) -> *mut Rc<Node>,
	pub loop_while: unsafe extern "C" fn(builder: *mut Builder, keyword: *const TokenPtr, cond: *mut Rc<Node>, do_: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub loop_while_mod: unsafe extern "C" fn(builder: *mut Builder, body: *mut Rc<Node>, cond: *mut Rc<Node>) -> *mut Rc<Node>,
	pub match_op: unsafe extern "C" fn(builder: *mut Builder, receiver: *mut Rc<Node>, oper: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub multi_assign: unsafe extern "C" fn(builder: *mut Builder, mlhs: *mut Rc<Node>, rhs: *mut Rc<Node>) -> *mut Rc<Node>,
	pub multi_lhs: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, items: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub negate: unsafe extern "C" fn(builder: *mut Builder, uminus: *const TokenPtr, numeric: *mut Rc<Node>) -> *mut Rc<Node>,
	pub nil: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub not_op: unsafe extern "C" fn(builder: *mut Builder, not_: *const TokenPtr, begin: *const TokenPtr, receiver: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub nth_ref: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub op_assign: unsafe extern "C" fn(builder: *mut Builder, lhs: *mut Rc<Node>, op: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node>,
	pub optarg: unsafe extern "C" fn(builder: *mut Builder, name: *const TokenPtr, eql: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node>,
	pub pair: unsafe extern "C" fn(builder: *mut Builder, key: *mut Rc<Node>, assoc: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node>,
	pub pair_keyword: unsafe extern "C" fn(builder: *mut Builder, key: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node>,
	pub pair_quoted: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node>,
	pub postexe: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, node: *mut Rc<Node>, rbrace: *const TokenPtr) -> *mut Rc<Node>,
	pub preexe: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, node: *mut Rc<Node>, rbrace: *const TokenPtr) -> *mut Rc<Node>,
	pub procarg0: unsafe extern "C" fn(builder: *mut Builder, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub prototype: unsafe extern "C" fn(builder: *mut Builder, genargs: *mut Rc<Node>, args: *mut Rc<Node>, return_type: *mut Rc<Node>) -> *mut Rc<Node>,
	pub range_exclusive: unsafe extern "C" fn(builder: *mut Builder, lhs: *mut Rc<Node>, oper: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node>,
	pub range_inclusive: unsafe extern "C" fn(builder: *mut Builder, lhs: *mut Rc<Node>, oper: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node>,
	pub rational: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub rational_complex: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub regexp_compose: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr, options: *mut Rc<Node>) -> *mut Rc<Node>,
	pub regexp_options: unsafe extern "C" fn(builder: *mut Builder, regopt: *const TokenPtr) -> *mut Rc<Node>,
	pub rescue_body: unsafe extern "C" fn(builder: *mut Builder, rescue: *const TokenPtr, exc_list: *mut Rc<Node>, assoc: *const TokenPtr, exc_var: *mut Rc<Node>, then: *const TokenPtr, body: *mut Rc<Node>) -> *mut Rc<Node>,
	pub restarg: unsafe extern "C" fn(builder: *mut Builder, star: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node>,
	pub self_: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub shadowarg: unsafe extern "C" fn(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node>,
	pub splat: unsafe extern "C" fn(builder: *mut Builder, star: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub string: unsafe extern "C" fn(builder: *mut Builder, string_: *const TokenPtr) -> *mut Rc<Node>,
	pub string_compose: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub string_internal: unsafe extern "C" fn(builder: *mut Builder, string_: *const TokenPtr) -> *mut Rc<Node>,
	pub symbol: unsafe extern "C" fn(builder: *mut Builder, symbol: *const TokenPtr) -> *mut Rc<Node>,
	pub symbol_compose: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub symbol_internal: unsafe extern "C" fn(builder: *mut Builder, symbol: *const TokenPtr) -> *mut Rc<Node>,
	pub symbols_compose: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub ternary: unsafe extern "C" fn(builder: *mut Builder, cond: *mut Rc<Node>, question: *const TokenPtr, if_true: *mut Rc<Node>, colon: *const TokenPtr, if_false: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_any: unsafe extern "C" fn(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_array: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, type_: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_cast: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, expr: *mut Rc<Node>, colon: *const TokenPtr, type_: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_class: unsafe extern "C" fn(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_consubtype: unsafe extern "C" fn(builder: *mut Builder, sub: *mut Rc<Node>, super_: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_conunify: unsafe extern "C" fn(builder: *mut Builder, a: *mut Rc<Node>, b: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_cpath: unsafe extern "C" fn(builder: *mut Builder, cpath: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_genargs: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, genargs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_gendecl: unsafe extern "C" fn(builder: *mut Builder, cpath: *mut Rc<Node>, begin: *const TokenPtr, genargs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_gendeclarg: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr, constraint: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_geninst: unsafe extern "C" fn(builder: *mut Builder, cpath: *mut Rc<Node>, begin: *const TokenPtr, genargs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_hash: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, key_type: *mut Rc<Node>, assoc: *const TokenPtr, value_type: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_instance: unsafe extern "C" fn(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_ivardecl: unsafe extern "C" fn(builder: *mut Builder, name: *const TokenPtr, type_: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_nil: unsafe extern "C" fn(builder: *mut Builder, nil: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_nillable: unsafe extern "C" fn(builder: *mut Builder, tilde: *const TokenPtr, type_: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_or: unsafe extern "C" fn(builder: *mut Builder, a: *mut Rc<Node>, b: *mut Rc<Node>) -> *mut Rc<Node>,
	pub tr_proc: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, args: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_self: unsafe extern "C" fn(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node>,
	pub tr_tuple: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, types: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub true_: unsafe extern "C" fn(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node>,
	pub typed_arg: unsafe extern "C" fn(builder: *mut Builder, type_: *mut Rc<Node>, arg: *mut Rc<Node>) -> *mut Rc<Node>,
	pub unary_op: unsafe extern "C" fn(builder: *mut Builder, oper: *const TokenPtr, receiver: *mut Rc<Node>) -> *mut Rc<Node>,
	pub undef_method: unsafe extern "C" fn(builder: *mut Builder, undef: *const TokenPtr, name_list: *mut NodeListPtr) -> *mut Rc<Node>,
	pub when: unsafe extern "C" fn(builder: *mut Builder, when: *const TokenPtr, patterns: *mut NodeListPtr, then: *const TokenPtr, body: *mut Rc<Node>) -> *mut Rc<Node>,
	pub word: unsafe extern "C" fn(builder: *mut Builder, parts: *mut NodeListPtr) -> *mut Rc<Node>,
	pub words_compose: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
	pub xstring_compose: unsafe extern "C" fn(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node>,
}


unsafe extern "C" fn accessible(builder: *mut Builder, node: *mut Rc<Node>) -> *mut Rc<Node> {
	let node = node_from_c(node);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).accessible(node).to_raw()
}
unsafe extern "C" fn alias(builder: *mut Builder, alias: *const TokenPtr, to: *mut Rc<Node>, from: *mut Rc<Node>) -> *mut Rc<Node> {
	let alias = token_from_c(alias);
	let to = node_from_c(to);
	let from = node_from_c(from);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).alias(alias, to, from).to_raw()
}
unsafe extern "C" fn arg(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node> {
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).arg(name).to_raw()
}
unsafe extern "C" fn args(builder: *mut Builder, begin: *const TokenPtr, args: *mut NodeListPtr, end: *const TokenPtr, check_args: bool) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let args = node_list_from_c(args);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).args(begin, args, end, check_args).to_raw()
}
unsafe extern "C" fn array(builder: *mut Builder, begin: *const TokenPtr, elements: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let elements = node_list_from_c(elements);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).array(begin, elements, end).to_raw()
}
unsafe extern "C" fn assign(builder: *mut Builder, lhs: *mut Rc<Node>, eql: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node> {
	let lhs = node_from_c(lhs);
	let eql = token_from_c(eql);
	let rhs = node_from_c(rhs);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).assign(lhs, eql, rhs).to_raw()
}
unsafe extern "C" fn assignable(builder: *mut Builder, node: *mut Rc<Node>) -> *mut Rc<Node> {
	let node = node_from_c(node);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).assignable(node).to_raw()
}
unsafe extern "C" fn associate(builder: *mut Builder, begin: *const TokenPtr, pairs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let pairs = node_list_from_c(pairs);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).associate(begin, pairs, end).to_raw()
}
unsafe extern "C" fn attr_asgn(builder: *mut Builder, receiver: *mut Rc<Node>, dot: *const TokenPtr, selector: *const TokenPtr) -> *mut Rc<Node> {
	let receiver = node_from_c(receiver);
	let dot = token_from_c(dot);
	let selector = token_from_c(selector);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).attr_asgn(receiver, dot, selector).to_raw()
}
unsafe extern "C" fn back_ref(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).back_ref(tok).to_raw()
}
unsafe extern "C" fn begin(builder: *mut Builder, begin: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).begin(begin, body, end).to_raw()
}
unsafe extern "C" fn begin_body(builder: *mut Builder, body: *mut Rc<Node>, rescue_bodies: *mut NodeListPtr, else_tok: *const TokenPtr, else_: *mut Rc<Node>, ensure_tok: *const TokenPtr, ensure: *mut Rc<Node>) -> *mut Rc<Node> {
	let body = node_from_c(body);
	let rescue_bodies = node_list_from_c(rescue_bodies);
	let else_tok = token_from_c(else_tok);
	let else_ = node_from_c(else_);
	let ensure_tok = token_from_c(ensure_tok);
	let ensure = node_from_c(ensure);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).begin_body(body, rescue_bodies, else_tok, else_, ensure_tok, ensure).to_raw()
}
unsafe extern "C" fn begin_keyword(builder: *mut Builder, begin: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).begin_keyword(begin, body, end).to_raw()
}
unsafe extern "C" fn binary_op(builder: *mut Builder, receiver: *mut Rc<Node>, oper: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let receiver = node_from_c(receiver);
	let oper = token_from_c(oper);
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).binary_op(receiver, oper, arg).to_raw()
}
unsafe extern "C" fn block(builder: *mut Builder, method_call: *mut Rc<Node>, begin: *const TokenPtr, args: *mut Rc<Node>, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let method_call = node_from_c(method_call);
	let begin = token_from_c(begin);
	let args = node_from_c(args);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).block(method_call, begin, args, body, end).to_raw()
}
unsafe extern "C" fn block_pass(builder: *mut Builder, amper: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let amper = token_from_c(amper);
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).block_pass(amper, arg).to_raw()
}
unsafe extern "C" fn blockarg(builder: *mut Builder, amper: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node> {
	let amper = token_from_c(amper);
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).blockarg(amper, name).to_raw()
}
unsafe extern "C" fn call_lambda(builder: *mut Builder, lambda: *const TokenPtr) -> *mut Rc<Node> {
	let lambda = token_from_c(lambda);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).call_lambda(lambda).to_raw()
}
unsafe extern "C" fn call_method(builder: *mut Builder, receiver: *mut Rc<Node>, dot: *const TokenPtr, selector: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node> {
	let receiver = node_from_c(receiver);
	let dot = token_from_c(dot);
	let selector = token_from_c(selector);
	let lparen = token_from_c(lparen);
	let args = node_list_from_c(args);
	let rparen = token_from_c(rparen);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).call_method(receiver, dot, selector, lparen, args, rparen).to_raw()
}
unsafe extern "C" fn case_(builder: *mut Builder, case_: *const TokenPtr, expr: *mut Rc<Node>, when_bodies: *mut NodeListPtr, else_tok: *const TokenPtr, else_body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let case_ = token_from_c(case_);
	let expr = node_from_c(expr);
	let when_bodies = node_list_from_c(when_bodies);
	let else_tok = token_from_c(else_tok);
	let else_body = node_from_c(else_body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).case_(case_, expr, when_bodies, else_tok, else_body, end).to_raw()
}
unsafe extern "C" fn character(builder: *mut Builder, char_: *const TokenPtr) -> *mut Rc<Node> {
	let char_ = token_from_c(char_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).character(char_).to_raw()
}
unsafe extern "C" fn complex(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).complex(tok).to_raw()
}
unsafe extern "C" fn compstmt(builder: *mut Builder, node: *mut NodeListPtr) -> *mut Rc<Node> {
	let node = node_list_from_c(node);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).compstmt(node).to_raw()
}
unsafe extern "C" fn condition(builder: *mut Builder, cond_tok: *const TokenPtr, cond: *mut Rc<Node>, then: *const TokenPtr, if_true: *mut Rc<Node>, else_: *const TokenPtr, if_false: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let cond_tok = token_from_c(cond_tok);
	let cond = node_from_c(cond);
	let then = token_from_c(then);
	let if_true = node_from_c(if_true);
	let else_ = token_from_c(else_);
	let if_false = node_from_c(if_false);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).condition(cond_tok, cond, then, if_true, else_, if_false, end).to_raw()
}
unsafe extern "C" fn condition_mod(builder: *mut Builder, if_true: *mut Rc<Node>, if_false: *mut Rc<Node>, cond: *mut Rc<Node>) -> *mut Rc<Node> {
	let if_true = node_from_c(if_true);
	let if_false = node_from_c(if_false);
	let cond = node_from_c(cond);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).condition_mod(if_true, if_false, cond).to_raw()
}
unsafe extern "C" fn const_(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node> {
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).const_(name).to_raw()
}
unsafe extern "C" fn const_fetch(builder: *mut Builder, scope: *mut Rc<Node>, colon: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node> {
	let scope = node_from_c(scope);
	let colon = token_from_c(colon);
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).const_fetch(scope, colon, name).to_raw()
}
unsafe extern "C" fn const_global(builder: *mut Builder, colon: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node> {
	let colon = token_from_c(colon);
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).const_global(colon, name).to_raw()
}
unsafe extern "C" fn const_op_assignable(builder: *mut Builder, node: *mut Rc<Node>) -> *mut Rc<Node> {
	let node = node_from_c(node);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).const_op_assignable(node).to_raw()
}
unsafe extern "C" fn cvar(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).cvar(tok).to_raw()
}
unsafe extern "C" fn dedent_string(builder: *mut Builder, node: *mut Rc<Node>, dedent_level: size_t) -> *mut Rc<Node> {
	let node = node_from_c(node);
	let dedent_level = dedent_level as usize;
	assert_eq!((*builder).cookie, 12345678);
	(*builder).dedent_string(node, dedent_level).to_raw()
}
unsafe extern "C" fn def_class(builder: *mut Builder, class_: *const TokenPtr, name: *mut Rc<Node>, lt_: *const TokenPtr, superclass: *mut Rc<Node>, body: *mut Rc<Node>, end_: *const TokenPtr) -> *mut Rc<Node> {
	let class_ = token_from_c(class_);
	let name = node_from_c(name);
	let lt_ = token_from_c(lt_);
	let superclass = node_from_c(superclass);
	let body = node_from_c(body);
	let end_ = token_from_c(end_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).def_class(class_, name, lt_, superclass, body, end_).to_raw()
}
unsafe extern "C" fn def_method(builder: *mut Builder, def: *const TokenPtr, name: *const TokenPtr, args: *mut Rc<Node>, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let def = token_from_c(def);
	let name = token_from_c(name);
	let args = node_from_c(args);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).def_method(def, name, args, body, end).to_raw()
}
unsafe extern "C" fn def_module(builder: *mut Builder, module: *const TokenPtr, name: *mut Rc<Node>, body: *mut Rc<Node>, end_: *const TokenPtr) -> *mut Rc<Node> {
	let module = token_from_c(module);
	let name = node_from_c(name);
	let body = node_from_c(body);
	let end_ = token_from_c(end_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).def_module(module, name, body, end_).to_raw()
}
unsafe extern "C" fn def_sclass(builder: *mut Builder, class_: *const TokenPtr, lshft_: *const TokenPtr, expr: *mut Rc<Node>, body: *mut Rc<Node>, end_: *const TokenPtr) -> *mut Rc<Node> {
	let class_ = token_from_c(class_);
	let lshft_ = token_from_c(lshft_);
	let expr = node_from_c(expr);
	let body = node_from_c(body);
	let end_ = token_from_c(end_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).def_sclass(class_, lshft_, expr, body, end_).to_raw()
}
unsafe extern "C" fn def_singleton(builder: *mut Builder, def: *const TokenPtr, definee: *mut Rc<Node>, dot: *const TokenPtr, name: *const TokenPtr, args: *mut Rc<Node>, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let def = token_from_c(def);
	let definee = node_from_c(definee);
	let dot = token_from_c(dot);
	let name = token_from_c(name);
	let args = node_from_c(args);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).def_singleton(def, definee, dot, name, args, body, end).to_raw()
}
unsafe extern "C" fn encoding_literal(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).encoding_literal(tok).to_raw()
}
unsafe extern "C" fn false_(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).false_(tok).to_raw()
}
unsafe extern "C" fn file_literal(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).file_literal(tok).to_raw()
}
unsafe extern "C" fn float_(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).float_(tok).to_raw()
}
unsafe extern "C" fn float_complex(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).float_complex(tok).to_raw()
}
unsafe extern "C" fn for_(builder: *mut Builder, for_: *const TokenPtr, iterator: *mut Rc<Node>, in_: *const TokenPtr, iteratee: *mut Rc<Node>, do_: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let for_ = token_from_c(for_);
	let iterator = node_from_c(iterator);
	let in_ = token_from_c(in_);
	let iteratee = node_from_c(iteratee);
	let do_ = token_from_c(do_);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).for_(for_, iterator, in_, iteratee, do_, body, end).to_raw()
}
unsafe extern "C" fn gvar(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).gvar(tok).to_raw()
}
unsafe extern "C" fn ident(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).ident(tok).to_raw()
}
unsafe extern "C" fn index(builder: *mut Builder, receiver: *mut Rc<Node>, lbrack: *const TokenPtr, indexes: *mut NodeListPtr, rbrack: *const TokenPtr) -> *mut Rc<Node> {
	let receiver = node_from_c(receiver);
	let lbrack = token_from_c(lbrack);
	let indexes = node_list_from_c(indexes);
	let rbrack = token_from_c(rbrack);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).index(receiver, lbrack, indexes, rbrack).to_raw()
}
unsafe extern "C" fn index_asgn(builder: *mut Builder, receiver: *mut Rc<Node>, lbrack: *const TokenPtr, indexes: *mut NodeListPtr, rbrack: *const TokenPtr) -> *mut Rc<Node> {
	let receiver = node_from_c(receiver);
	let lbrack = token_from_c(lbrack);
	let indexes = node_list_from_c(indexes);
	let rbrack = token_from_c(rbrack);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).index_asgn(receiver, lbrack, indexes, rbrack).to_raw()
}
unsafe extern "C" fn integer(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).integer(tok).to_raw()
}
unsafe extern "C" fn ivar(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).ivar(tok).to_raw()
}
unsafe extern "C" fn keyword_break(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let lparen = token_from_c(lparen);
	let args = node_list_from_c(args);
	let rparen = token_from_c(rparen);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_break(keyword, lparen, args, rparen).to_raw()
}
unsafe extern "C" fn keyword_defined(builder: *mut Builder, keyword: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_defined(keyword, arg).to_raw()
}
unsafe extern "C" fn keyword_next(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let lparen = token_from_c(lparen);
	let args = node_list_from_c(args);
	let rparen = token_from_c(rparen);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_next(keyword, lparen, args, rparen).to_raw()
}
unsafe extern "C" fn keyword_redo(builder: *mut Builder, keyword: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_redo(keyword).to_raw()
}
unsafe extern "C" fn keyword_retry(builder: *mut Builder, keyword: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_retry(keyword).to_raw()
}
unsafe extern "C" fn keyword_return(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let lparen = token_from_c(lparen);
	let args = node_list_from_c(args);
	let rparen = token_from_c(rparen);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_return(keyword, lparen, args, rparen).to_raw()
}
unsafe extern "C" fn keyword_super(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let lparen = token_from_c(lparen);
	let args = node_list_from_c(args);
	let rparen = token_from_c(rparen);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_super(keyword, lparen, args, rparen).to_raw()
}
unsafe extern "C" fn keyword_yield(builder: *mut Builder, keyword: *const TokenPtr, lparen: *const TokenPtr, args: *mut NodeListPtr, rparen: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let lparen = token_from_c(lparen);
	let args = node_list_from_c(args);
	let rparen = token_from_c(rparen);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_yield(keyword, lparen, args, rparen).to_raw()
}
unsafe extern "C" fn keyword_zsuper(builder: *mut Builder, keyword: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).keyword_zsuper(keyword).to_raw()
}
unsafe extern "C" fn kwarg(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node> {
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).kwarg(name).to_raw()
}
unsafe extern "C" fn kwoptarg(builder: *mut Builder, name: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node> {
	let name = token_from_c(name);
	let value = node_from_c(value);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).kwoptarg(name, value).to_raw()
}
unsafe extern "C" fn kwrestarg(builder: *mut Builder, dstar: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node> {
	let dstar = token_from_c(dstar);
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).kwrestarg(dstar, name).to_raw()
}
unsafe extern "C" fn kwsplat(builder: *mut Builder, dstar: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let dstar = token_from_c(dstar);
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).kwsplat(dstar, arg).to_raw()
}
unsafe extern "C" fn line_literal(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).line_literal(tok).to_raw()
}
unsafe extern "C" fn logical_and(builder: *mut Builder, lhs: *mut Rc<Node>, op: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node> {
	let lhs = node_from_c(lhs);
	let op = token_from_c(op);
	let rhs = node_from_c(rhs);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).logical_and(lhs, op, rhs).to_raw()
}
unsafe extern "C" fn logical_or(builder: *mut Builder, lhs: *mut Rc<Node>, op: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node> {
	let lhs = node_from_c(lhs);
	let op = token_from_c(op);
	let rhs = node_from_c(rhs);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).logical_or(lhs, op, rhs).to_raw()
}
unsafe extern "C" fn loop_until(builder: *mut Builder, keyword: *const TokenPtr, cond: *mut Rc<Node>, do_: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let cond = node_from_c(cond);
	let do_ = token_from_c(do_);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).loop_until(keyword, cond, do_, body, end).to_raw()
}
unsafe extern "C" fn loop_until_mod(builder: *mut Builder, body: *mut Rc<Node>, cond: *mut Rc<Node>) -> *mut Rc<Node> {
	let body = node_from_c(body);
	let cond = node_from_c(cond);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).loop_until_mod(body, cond).to_raw()
}
unsafe extern "C" fn loop_while(builder: *mut Builder, keyword: *const TokenPtr, cond: *mut Rc<Node>, do_: *const TokenPtr, body: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let keyword = token_from_c(keyword);
	let cond = node_from_c(cond);
	let do_ = token_from_c(do_);
	let body = node_from_c(body);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).loop_while(keyword, cond, do_, body, end).to_raw()
}
unsafe extern "C" fn loop_while_mod(builder: *mut Builder, body: *mut Rc<Node>, cond: *mut Rc<Node>) -> *mut Rc<Node> {
	let body = node_from_c(body);
	let cond = node_from_c(cond);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).loop_while_mod(body, cond).to_raw()
}
unsafe extern "C" fn match_op(builder: *mut Builder, receiver: *mut Rc<Node>, oper: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let receiver = node_from_c(receiver);
	let oper = token_from_c(oper);
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).match_op(receiver, oper, arg).to_raw()
}
unsafe extern "C" fn multi_assign(builder: *mut Builder, mlhs: *mut Rc<Node>, rhs: *mut Rc<Node>) -> *mut Rc<Node> {
	let mlhs = node_from_c(mlhs);
	let rhs = node_from_c(rhs);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).multi_assign(mlhs, rhs).to_raw()
}
unsafe extern "C" fn multi_lhs(builder: *mut Builder, begin: *const TokenPtr, items: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let items = node_list_from_c(items);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).multi_lhs(begin, items, end).to_raw()
}
unsafe extern "C" fn negate(builder: *mut Builder, uminus: *const TokenPtr, numeric: *mut Rc<Node>) -> *mut Rc<Node> {
	let uminus = token_from_c(uminus);
	let numeric = node_from_c(numeric);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).negate(uminus, numeric).to_raw()
}
unsafe extern "C" fn nil(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).nil(tok).to_raw()
}
unsafe extern "C" fn not_op(builder: *mut Builder, not_: *const TokenPtr, begin: *const TokenPtr, receiver: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let not_ = token_from_c(not_);
	let begin = token_from_c(begin);
	let receiver = node_from_c(receiver);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).not_op(not_, begin, receiver, end).to_raw()
}
unsafe extern "C" fn nth_ref(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).nth_ref(tok).to_raw()
}
unsafe extern "C" fn op_assign(builder: *mut Builder, lhs: *mut Rc<Node>, op: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node> {
	let lhs = node_from_c(lhs);
	let op = token_from_c(op);
	let rhs = node_from_c(rhs);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).op_assign(lhs, op, rhs).to_raw()
}
unsafe extern "C" fn optarg(builder: *mut Builder, name: *const TokenPtr, eql: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node> {
	let name = token_from_c(name);
	let eql = token_from_c(eql);
	let value = node_from_c(value);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).optarg(name, eql, value).to_raw()
}
unsafe extern "C" fn pair(builder: *mut Builder, key: *mut Rc<Node>, assoc: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node> {
	let key = node_from_c(key);
	let assoc = token_from_c(assoc);
	let value = node_from_c(value);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).pair(key, assoc, value).to_raw()
}
unsafe extern "C" fn pair_keyword(builder: *mut Builder, key: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node> {
	let key = token_from_c(key);
	let value = node_from_c(value);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).pair_keyword(key, value).to_raw()
}
unsafe extern "C" fn pair_quoted(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr, value: *mut Rc<Node>) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let parts = node_list_from_c(parts);
	let end = token_from_c(end);
	let value = node_from_c(value);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).pair_quoted(begin, parts, end, value).to_raw()
}
unsafe extern "C" fn postexe(builder: *mut Builder, begin: *const TokenPtr, node: *mut Rc<Node>, rbrace: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let node = node_from_c(node);
	let rbrace = token_from_c(rbrace);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).postexe(begin, node, rbrace).to_raw()
}
unsafe extern "C" fn preexe(builder: *mut Builder, begin: *const TokenPtr, node: *mut Rc<Node>, rbrace: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let node = node_from_c(node);
	let rbrace = token_from_c(rbrace);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).preexe(begin, node, rbrace).to_raw()
}
unsafe extern "C" fn procarg0(builder: *mut Builder, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).procarg0(arg).to_raw()
}
unsafe extern "C" fn prototype(builder: *mut Builder, genargs: *mut Rc<Node>, args: *mut Rc<Node>, return_type: *mut Rc<Node>) -> *mut Rc<Node> {
	let genargs = node_from_c(genargs);
	let args = node_from_c(args);
	let return_type = node_from_c(return_type);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).prototype(genargs, args, return_type).to_raw()
}
unsafe extern "C" fn range_exclusive(builder: *mut Builder, lhs: *mut Rc<Node>, oper: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node> {
	let lhs = node_from_c(lhs);
	let oper = token_from_c(oper);
	let rhs = node_from_c(rhs);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).range_exclusive(lhs, oper, rhs).to_raw()
}
unsafe extern "C" fn range_inclusive(builder: *mut Builder, lhs: *mut Rc<Node>, oper: *const TokenPtr, rhs: *mut Rc<Node>) -> *mut Rc<Node> {
	let lhs = node_from_c(lhs);
	let oper = token_from_c(oper);
	let rhs = node_from_c(rhs);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).range_inclusive(lhs, oper, rhs).to_raw()
}
unsafe extern "C" fn rational(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).rational(tok).to_raw()
}
unsafe extern "C" fn rational_complex(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).rational_complex(tok).to_raw()
}
unsafe extern "C" fn regexp_compose(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr, options: *mut Rc<Node>) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let parts = node_list_from_c(parts);
	let end = token_from_c(end);
	let options = node_from_c(options);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).regexp_compose(begin, parts, end, options).to_raw()
}
unsafe extern "C" fn regexp_options(builder: *mut Builder, regopt: *const TokenPtr) -> *mut Rc<Node> {
	let regopt = token_from_c(regopt);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).regexp_options(regopt).to_raw()
}
unsafe extern "C" fn rescue_body(builder: *mut Builder, rescue: *const TokenPtr, exc_list: *mut Rc<Node>, assoc: *const TokenPtr, exc_var: *mut Rc<Node>, then: *const TokenPtr, body: *mut Rc<Node>) -> *mut Rc<Node> {
	let rescue = token_from_c(rescue);
	let exc_list = node_from_c(exc_list);
	let assoc = token_from_c(assoc);
	let exc_var = node_from_c(exc_var);
	let then = token_from_c(then);
	let body = node_from_c(body);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).rescue_body(rescue, exc_list, assoc, exc_var, then, body).to_raw()
}
unsafe extern "C" fn restarg(builder: *mut Builder, star: *const TokenPtr, name: *const TokenPtr) -> *mut Rc<Node> {
	let star = token_from_c(star);
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).restarg(star, name).to_raw()
}
unsafe extern "C" fn self_(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).self_(tok).to_raw()
}
unsafe extern "C" fn shadowarg(builder: *mut Builder, name: *const TokenPtr) -> *mut Rc<Node> {
	let name = token_from_c(name);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).shadowarg(name).to_raw()
}
unsafe extern "C" fn splat(builder: *mut Builder, star: *const TokenPtr, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let star = token_from_c(star);
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).splat(star, arg).to_raw()
}
unsafe extern "C" fn string(builder: *mut Builder, string_: *const TokenPtr) -> *mut Rc<Node> {
	let string_ = token_from_c(string_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).string(string_).to_raw()
}
unsafe extern "C" fn string_compose(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let parts = node_list_from_c(parts);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).string_compose(begin, parts, end).to_raw()
}
unsafe extern "C" fn string_internal(builder: *mut Builder, string_: *const TokenPtr) -> *mut Rc<Node> {
	let string_ = token_from_c(string_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).string_internal(string_).to_raw()
}
unsafe extern "C" fn symbol(builder: *mut Builder, symbol: *const TokenPtr) -> *mut Rc<Node> {
	let symbol = token_from_c(symbol);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).symbol(symbol).to_raw()
}
unsafe extern "C" fn symbol_compose(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let parts = node_list_from_c(parts);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).symbol_compose(begin, parts, end).to_raw()
}
unsafe extern "C" fn symbol_internal(builder: *mut Builder, symbol: *const TokenPtr) -> *mut Rc<Node> {
	let symbol = token_from_c(symbol);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).symbol_internal(symbol).to_raw()
}
unsafe extern "C" fn symbols_compose(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let parts = node_list_from_c(parts);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).symbols_compose(begin, parts, end).to_raw()
}
unsafe extern "C" fn ternary(builder: *mut Builder, cond: *mut Rc<Node>, question: *const TokenPtr, if_true: *mut Rc<Node>, colon: *const TokenPtr, if_false: *mut Rc<Node>) -> *mut Rc<Node> {
	let cond = node_from_c(cond);
	let question = token_from_c(question);
	let if_true = node_from_c(if_true);
	let colon = token_from_c(colon);
	let if_false = node_from_c(if_false);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).ternary(cond, question, if_true, colon, if_false).to_raw()
}
unsafe extern "C" fn tr_any(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node> {
	let special = token_from_c(special);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_any(special).to_raw()
}
unsafe extern "C" fn tr_array(builder: *mut Builder, begin: *const TokenPtr, type_: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let type_ = node_from_c(type_);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_array(begin, type_, end).to_raw()
}
unsafe extern "C" fn tr_cast(builder: *mut Builder, begin: *const TokenPtr, expr: *mut Rc<Node>, colon: *const TokenPtr, type_: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let expr = node_from_c(expr);
	let colon = token_from_c(colon);
	let type_ = node_from_c(type_);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_cast(begin, expr, colon, type_, end).to_raw()
}
unsafe extern "C" fn tr_class(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node> {
	let special = token_from_c(special);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_class(special).to_raw()
}
unsafe extern "C" fn tr_consubtype(builder: *mut Builder, sub: *mut Rc<Node>, super_: *mut Rc<Node>) -> *mut Rc<Node> {
	let sub = node_from_c(sub);
	let super_ = node_from_c(super_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_consubtype(sub, super_).to_raw()
}
unsafe extern "C" fn tr_conunify(builder: *mut Builder, a: *mut Rc<Node>, b: *mut Rc<Node>) -> *mut Rc<Node> {
	let a = node_from_c(a);
	let b = node_from_c(b);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_conunify(a, b).to_raw()
}
unsafe extern "C" fn tr_cpath(builder: *mut Builder, cpath: *mut Rc<Node>) -> *mut Rc<Node> {
	let cpath = node_from_c(cpath);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_cpath(cpath).to_raw()
}
unsafe extern "C" fn tr_genargs(builder: *mut Builder, begin: *const TokenPtr, genargs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let genargs = node_list_from_c(genargs);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_genargs(begin, genargs, end).to_raw()
}
unsafe extern "C" fn tr_gendecl(builder: *mut Builder, cpath: *mut Rc<Node>, begin: *const TokenPtr, genargs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let cpath = node_from_c(cpath);
	let begin = token_from_c(begin);
	let genargs = node_list_from_c(genargs);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_gendecl(cpath, begin, genargs, end).to_raw()
}
unsafe extern "C" fn tr_gendeclarg(builder: *mut Builder, tok: *const TokenPtr, constraint: *mut Rc<Node>) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	let constraint = node_from_c(constraint);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_gendeclarg(tok, constraint).to_raw()
}
unsafe extern "C" fn tr_geninst(builder: *mut Builder, cpath: *mut Rc<Node>, begin: *const TokenPtr, genargs: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let cpath = node_from_c(cpath);
	let begin = token_from_c(begin);
	let genargs = node_list_from_c(genargs);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_geninst(cpath, begin, genargs, end).to_raw()
}
unsafe extern "C" fn tr_hash(builder: *mut Builder, begin: *const TokenPtr, key_type: *mut Rc<Node>, assoc: *const TokenPtr, value_type: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let key_type = node_from_c(key_type);
	let assoc = token_from_c(assoc);
	let value_type = node_from_c(value_type);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_hash(begin, key_type, assoc, value_type, end).to_raw()
}
unsafe extern "C" fn tr_instance(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node> {
	let special = token_from_c(special);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_instance(special).to_raw()
}
unsafe extern "C" fn tr_ivardecl(builder: *mut Builder, name: *const TokenPtr, type_: *mut Rc<Node>) -> *mut Rc<Node> {
	let name = token_from_c(name);
	let type_ = node_from_c(type_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_ivardecl(name, type_).to_raw()
}
unsafe extern "C" fn tr_nil(builder: *mut Builder, nil: *const TokenPtr) -> *mut Rc<Node> {
	let nil = token_from_c(nil);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_nil(nil).to_raw()
}
unsafe extern "C" fn tr_nillable(builder: *mut Builder, tilde: *const TokenPtr, type_: *mut Rc<Node>) -> *mut Rc<Node> {
	let tilde = token_from_c(tilde);
	let type_ = node_from_c(type_);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_nillable(tilde, type_).to_raw()
}
unsafe extern "C" fn tr_or(builder: *mut Builder, a: *mut Rc<Node>, b: *mut Rc<Node>) -> *mut Rc<Node> {
	let a = node_from_c(a);
	let b = node_from_c(b);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_or(a, b).to_raw()
}
unsafe extern "C" fn tr_proc(builder: *mut Builder, begin: *const TokenPtr, args: *mut Rc<Node>, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let args = node_from_c(args);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_proc(begin, args, end).to_raw()
}
unsafe extern "C" fn tr_self(builder: *mut Builder, special: *const TokenPtr) -> *mut Rc<Node> {
	let special = token_from_c(special);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_self(special).to_raw()
}
unsafe extern "C" fn tr_tuple(builder: *mut Builder, begin: *const TokenPtr, types: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let types = node_list_from_c(types);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).tr_tuple(begin, types, end).to_raw()
}
unsafe extern "C" fn true_(builder: *mut Builder, tok: *const TokenPtr) -> *mut Rc<Node> {
	let tok = token_from_c(tok);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).true_(tok).to_raw()
}
unsafe extern "C" fn typed_arg(builder: *mut Builder, type_: *mut Rc<Node>, arg: *mut Rc<Node>) -> *mut Rc<Node> {
	let type_ = node_from_c(type_);
	let arg = node_from_c(arg);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).typed_arg(type_, arg).to_raw()
}
unsafe extern "C" fn unary_op(builder: *mut Builder, oper: *const TokenPtr, receiver: *mut Rc<Node>) -> *mut Rc<Node> {
	let oper = token_from_c(oper);
	let receiver = node_from_c(receiver);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).unary_op(oper, receiver).to_raw()
}
unsafe extern "C" fn undef_method(builder: *mut Builder, undef: *const TokenPtr, name_list: *mut NodeListPtr) -> *mut Rc<Node> {
	let undef = token_from_c(undef);
	let name_list = node_list_from_c(name_list);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).undef_method(undef, name_list).to_raw()
}
unsafe extern "C" fn when(builder: *mut Builder, when: *const TokenPtr, patterns: *mut NodeListPtr, then: *const TokenPtr, body: *mut Rc<Node>) -> *mut Rc<Node> {
	let when = token_from_c(when);
	let patterns = node_list_from_c(patterns);
	let then = token_from_c(then);
	let body = node_from_c(body);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).when(when, patterns, then, body).to_raw()
}
unsafe extern "C" fn word(builder: *mut Builder, parts: *mut NodeListPtr) -> *mut Rc<Node> {
	let parts = node_list_from_c(parts);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).word(parts).to_raw()
}
unsafe extern "C" fn words_compose(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let parts = node_list_from_c(parts);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).words_compose(begin, parts, end).to_raw()
}
unsafe extern "C" fn xstring_compose(builder: *mut Builder, begin: *const TokenPtr, parts: *mut NodeListPtr, end: *const TokenPtr) -> *mut Rc<Node> {
	let begin = token_from_c(begin);
	let parts = node_list_from_c(parts);
	let end = token_from_c(end);
	assert_eq!((*builder).cookie, 12345678);
	(*builder).xstring_compose(begin, parts, end).to_raw()
}


static CALLBACKS: BuilderInterface = BuilderInterface {
	accessible: accessible,
	alias: alias,
	arg: arg,
	args: args,
	array: array,
	assign: assign,
	assignable: assignable,
	associate: associate,
	attr_asgn: attr_asgn,
	back_ref: back_ref,
	begin: begin,
	begin_body: begin_body,
	begin_keyword: begin_keyword,
	binary_op: binary_op,
	block: block,
	block_pass: block_pass,
	blockarg: blockarg,
	call_lambda: call_lambda,
	call_method: call_method,
	case_: case_,
	character: character,
	complex: complex,
	compstmt: compstmt,
	condition: condition,
	condition_mod: condition_mod,
	const_: const_,
	const_fetch: const_fetch,
	const_global: const_global,
	const_op_assignable: const_op_assignable,
	cvar: cvar,
	dedent_string: dedent_string,
	def_class: def_class,
	def_method: def_method,
	def_module: def_module,
	def_sclass: def_sclass,
	def_singleton: def_singleton,
	encoding_literal: encoding_literal,
	false_: false_,
	file_literal: file_literal,
	float_: float_,
	float_complex: float_complex,
	for_: for_,
	gvar: gvar,
	ident: ident,
	index: index,
	index_asgn: index_asgn,
	integer: integer,
	ivar: ivar,
	keyword_break: keyword_break,
	keyword_defined: keyword_defined,
	keyword_next: keyword_next,
	keyword_redo: keyword_redo,
	keyword_retry: keyword_retry,
	keyword_return: keyword_return,
	keyword_super: keyword_super,
	keyword_yield: keyword_yield,
	keyword_zsuper: keyword_zsuper,
	kwarg: kwarg,
	kwoptarg: kwoptarg,
	kwrestarg: kwrestarg,
	kwsplat: kwsplat,
	line_literal: line_literal,
	logical_and: logical_and,
	logical_or: logical_or,
	loop_until: loop_until,
	loop_until_mod: loop_until_mod,
	loop_while: loop_while,
	loop_while_mod: loop_while_mod,
	match_op: match_op,
	multi_assign: multi_assign,
	multi_lhs: multi_lhs,
	negate: negate,
	nil: nil,
	not_op: not_op,
	nth_ref: nth_ref,
	op_assign: op_assign,
	optarg: optarg,
	pair: pair,
	pair_keyword: pair_keyword,
	pair_quoted: pair_quoted,
	postexe: postexe,
	preexe: preexe,
	procarg0: procarg0,
	prototype: prototype,
	range_exclusive: range_exclusive,
	range_inclusive: range_inclusive,
	rational: rational,
	rational_complex: rational_complex,
	regexp_compose: regexp_compose,
	regexp_options: regexp_options,
	rescue_body: rescue_body,
	restarg: restarg,
	self_: self_,
	shadowarg: shadowarg,
	splat: splat,
	string: string,
	string_compose: string_compose,
	string_internal: string_internal,
	symbol: symbol,
	symbol_compose: symbol_compose,
	symbol_internal: symbol_internal,
	symbols_compose: symbols_compose,
	ternary: ternary,
	tr_any: tr_any,
	tr_array: tr_array,
	tr_cast: tr_cast,
	tr_class: tr_class,
	tr_consubtype: tr_consubtype,
	tr_conunify: tr_conunify,
	tr_cpath: tr_cpath,
	tr_genargs: tr_genargs,
	tr_gendecl: tr_gendecl,
	tr_gendeclarg: tr_gendeclarg,
	tr_geninst: tr_geninst,
	tr_hash: tr_hash,
	tr_instance: tr_instance,
	tr_ivardecl: tr_ivardecl,
	tr_nil: tr_nil,
	tr_nillable: tr_nillable,
	tr_or: tr_or,
	tr_proc: tr_proc,
	tr_self: tr_self,
	tr_tuple: tr_tuple,
	true_: true_,
	typed_arg: typed_arg,
	unary_op: unary_op,
	undef_method: undef_method,
	when: when,
	word: word,
	words_compose: words_compose,
	xstring_compose: xstring_compose,
};
