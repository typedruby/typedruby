use std::fmt;
use ast::{Diagnostic};
#[repr(C)]
#[derive(Debug)]
#[derive(PartialEq)]
pub enum Error {
    UnicodePointTooLarge,
    InvalidEscape,
    IncompleteEscape,
    InvalidHexEscape,
    InvalidUnicodeEscape,
    UnterminatedUnicode,
    EscapeEof,
    StringEof,
    RegexpOptions,
    CvarName,
    IvarName,
    TrailingInNumber,
    EmptyNumeric,
    InvalidOctal,
    NoDotDigitLiteral,
    BareBackslash,
    Unexpected,
    EmbeddedDocument,
    InvalidEscapeUse,
    AmbiguousLiteral,
    AmbiguousPrefix,
    NthRefAlias,
    BeginInMethod,
    BackrefAssignment,
    InvalidAssignment,
    ModuleNameConst,
    UnexpectedToken,
    ArgumentConst,
    ArgumentIvar,
    ArgumentGvar,
    ArgumentCvar,
    DuplicateArgument,
    EmptySymbol,
    OddHash,
    SingletonLiteral,
    DynamicConst,
    ConstReassignment,
    ModuleInDef,
    ClassInDef,
    UnexpectedPercentStr,
    BlockAndBlockarg,
    MasgnAsCondition,
    BlockGivenToYield,
    InvalidRegexp,
    UselessElse,
    InvalidEncoding,
    InvalidAction,
    Clobbered,
}


impl fmt::Display for Diagnostic {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let arg1 = match self.data { Some(ref str) => str.as_str(), None => "[??]" };
        match self.error {
            Error::UnicodePointTooLarge => write!(f, "{:?}: invalid Unicode codepoint (too large)", self.level),
            Error::InvalidEscape => write!(f, "{:?}: invalid escape character syntax", self.level),
            Error::IncompleteEscape => write!(f, "{:?}: incomplete character syntax", self.level),
            Error::InvalidHexEscape => write!(f, "{:?}: invalid hex escape", self.level),
            Error::InvalidUnicodeEscape => write!(f, "{:?}: invalid Unicode escape", self.level),
            Error::UnterminatedUnicode => write!(f, "{:?}: unterminated Unicode escape", self.level),
            Error::EscapeEof => write!(f, "{:?}: escape sequence meets end of file", self.level),
            Error::StringEof => write!(f, "{:?}: unterminated string meets end of file", self.level),
            Error::RegexpOptions => write!(f, "{:?}: unknown regexp options: {}", self.level, arg1),
            Error::CvarName => write!(f, "{:?}: `{}' is not allowed as a class variable name", self.level, arg1),
            Error::IvarName => write!(f, "{:?}: `{}' is not allowed as an instance variable name", self.level, arg1),
            Error::TrailingInNumber => write!(f, "{:?}: trailing `{}' in number", self.level, arg1),
            Error::EmptyNumeric => write!(f, "{:?}: numeric literal without digits", self.level),
            Error::InvalidOctal => write!(f, "{:?}: invalid octal digit", self.level),
            Error::NoDotDigitLiteral => write!(f, "{:?}: no .<digit> floating literal anymore; put 0 before dot", self.level),
            Error::BareBackslash => write!(f, "{:?}: bare backslash only allowed before newline", self.level),
            Error::Unexpected => write!(f, "{:?}: unexpected `{}'", self.level, arg1),
            Error::EmbeddedDocument => write!(f, "{:?}: embedded document meets end of file (and they embark on a romantic journey)", self.level),
            Error::InvalidEscapeUse => write!(f, "{:?}: invalid character syntax; use ?{}", self.level, arg1),
            Error::AmbiguousLiteral => write!(f, "{:?}: ambiguous first argument; put parentheses or a space even after the operator", self.level),
            Error::AmbiguousPrefix => write!(f, "{:?}: `{}' interpreted as argument prefix", self.level, arg1),
            Error::NthRefAlias => write!(f, "{:?}: cannot define an alias for a back-reference variable", self.level),
            Error::BeginInMethod => write!(f, "{:?}: BEGIN in method", self.level),
            Error::BackrefAssignment => write!(f, "{:?}: cannot assign to a back-reference variable", self.level),
            Error::InvalidAssignment => write!(f, "{:?}: cannot assign to a keyword", self.level),
            Error::ModuleNameConst => write!(f, "{:?}: class or module name must be a constant literal", self.level),
            Error::UnexpectedToken => write!(f, "{:?}: unexpected token: {}", self.level, arg1),
            Error::ArgumentConst => write!(f, "{:?}: formal argument cannot be a constant", self.level),
            Error::ArgumentIvar => write!(f, "{:?}: formal argument cannot be an instance variable", self.level),
            Error::ArgumentGvar => write!(f, "{:?}: formal argument cannot be a global variable", self.level),
            Error::ArgumentCvar => write!(f, "{:?}: formal argument cannot be a class variable", self.level),
            Error::DuplicateArgument => write!(f, "{:?}: duplicate argument name", self.level),
            Error::EmptySymbol => write!(f, "{:?}: empty symbol literal", self.level),
            Error::OddHash => write!(f, "{:?}: odd number of entries for a hash", self.level),
            Error::SingletonLiteral => write!(f, "{:?}: cannot define a singleton method for a literal", self.level),
            Error::DynamicConst => write!(f, "{:?}: dynamic constant assignment", self.level),
            Error::ConstReassignment => write!(f, "{:?}: constant re-assignment", self.level),
            Error::ModuleInDef => write!(f, "{:?}: module definition in method body", self.level),
            Error::ClassInDef => write!(f, "{:?}: class definition in method body", self.level),
            Error::UnexpectedPercentStr => write!(f, "{:?}: {}: unknown type of percent-literal", self.level, arg1),
            Error::BlockAndBlockarg => write!(f, "{:?}: both block argument and literal block are passed", self.level),
            Error::MasgnAsCondition => write!(f, "{:?}: multiple assignment in conditional context", self.level),
            Error::BlockGivenToYield => write!(f, "{:?}: block given to yield", self.level),
            Error::InvalidRegexp => write!(f, "{:?}: {}", self.level, arg1),
            Error::UselessElse => write!(f, "{:?}: else without rescue is useless", self.level),
            Error::InvalidEncoding => write!(f, "{:?}: literal contains escape sequences incompatible with UTF-8", self.level),
            Error::InvalidAction => write!(f, "{:?}: cannot {}", self.level, arg1),
            Error::Clobbered => write!(f, "{:?}: clobbered by: {}", self.level, arg1),
        }
    }
}
