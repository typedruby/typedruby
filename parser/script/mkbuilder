#!/usr/bin/env ruby

RE_BODY = /struct builder \{(.*?)\}/m
RE_FUNC = /foreign_ptr\(\*(\w+)\)\((.*?)\);/

CHECK_COOKIES = false
TYPE_CONVERSION = {
  "foreign_ptr" => "*mut Rc<Node>",
  "const token*" => "*const TokenPtr",
  "const node_list*" => "*mut NodeListPtr",
  "bool" => "bool",
  "size_t" => "size_t",
  "self_ptr" => "*mut Builder",
}

filename = ARGV.first
abort("missing input filename") unless filename

class Argument
  attr_reader :type
  attr_reader :name

  def initialize(type, name)
    @type = type
    @name = name
  end

  def as_arg
    "#{name}: #{type}"
  end

  def as_safe_arg
    if type == "*mut Builder"
      return "&self"
    end

    t = case type
        when "*mut Rc<Node>"
          "Option<Rc<Node>>"
        when "*mut NodeListPtr"
          "Vec<Rc<Node>>"
        when "*const TokenPtr"
          "Option<Token>"
        when "size_t"
          "usize"
        else
          type
        end

    "#{name}: #{t}"
  end

  def as_param
    name
  end

  def convert
    case type
    when "*mut Rc<Node>"
      "let #{name} = node_from_c(#{name})"
    when "*mut NodeListPtr"
      "let #{name} = node_list_from_c(#{name})"
    when "*const TokenPtr"
      "let #{name} = token_from_c(#{name})"
    when "size_t"
      "let #{name} = #{name} as usize"
    end
  end
end

class Interface
  attr_reader :name
  attr_reader :args

  def initialize(name, args)
    @name = name
    @args = args
  end

  def arg_block
    args.map {|a| a.as_arg }.join(", ")
  end

  def signature
    "pub #{name}: unsafe extern \"C\" fn(#{arg_block}) -> *mut Rc<Node>"
  end

  def signature_safe
    _args = args.map {|a| a.as_safe_arg }.join(", ")
    "fn #{name}(#{_args}) -> Rc<Node>"
  end

  def definition
    "unsafe extern \"C\" fn #{name}(#{arg_block}) -> *mut Rc<Node>"
  end

  def callsite
    _args = args[1..-1].map {|a| a.as_param }.join(", ")
    "(*#{args.first.name}).#{name}(#{_args})"
  end

  def cookie_check
    "assert_eq!((*#{args.first.name}).cookie, 12345678)"
  end
end

def get_definitions(filename)
  cpp = File.read(filename)
  builder = RE_BODY.match(cpp)

  abort("failed to match 'struct builder' body in #{filename}") unless builder
  defs = builder[1].split("\n").map { |d| d.strip }.reject { |d| d.empty? }

  defs.map do |d|
    match = RE_FUNC.match(d)
    abort("bad definition: '#{d}'") unless match
    method, args = match[1], match[2]

    args = args.split(",").map { |a| a.strip }
    args = args.map do |arg|
      arg = arg.split(' ')
      argname = arg.pop
      ctype = arg.join(' ')
      rstype = TYPE_CONVERSION[ctype]
      abort("unknown C type: #{ctype}") unless rstype

      Argument.new(rstype, argname)
    end

    Interface.new(method, args)
  end
end

apis = get_definitions(filename)

puts "// This file is autogenerated by script/mkbuilder"
puts "// DO NOT MODIFY"
puts "#[repr(C)]"
puts "struct BuilderInterface {"

apis.each do |api|
  puts "\t#{api.signature},"
end

puts "}"
puts "\n\n"

apis.each do |api|
  puts "#{api.definition} {"
  api.args.each do |arg|
    cv = arg.convert
    puts "\t#{cv};" if cv
  end
  puts "\t#{api.cookie_check};" if CHECK_COOKIES
  puts "\t#{api.callsite}.to_raw()"
  puts "}"
end

puts "\n\n"

puts "static CALLBACKS: BuilderInterface = BuilderInterface {"
apis.each do |api|
  puts "\t#{api.name}: #{api.name},"
end
puts "};"

