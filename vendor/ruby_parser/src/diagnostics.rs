use std::fmt;
use ast::{Diagnostic};
#[repr(C)]
#[derive(Debug)]
#[derive(PartialEq)]
pub enum Error {
    UnicodePointTooLarge,
    InvalidEscape,
    IncompleteEscape,
    InvalidHexEscape,
    InvalidUnicodeEscape,
    UnterminatedUnicode,
    EscapeEof,
    StringEof,
    RegexpOptions,
    CvarName,
    IvarName,
    TrailingInNumber,
    EmptyNumeric,
    InvalidOctal,
    NoDotDigitLiteral,
    BareBackslash,
    Unexpected,
    EmbeddedDocument,
    InvalidEscapeUse,
    AmbiguousLiteral,
    AmbiguousPrefix,
    NthRefAlias,
    BeginInMethod,
    BackrefAssignment,
    InvalidAssignment,
    ModuleNameConst,
    UnexpectedToken,
    ArgumentConst,
    ArgumentIvar,
    ArgumentGvar,
    ArgumentCvar,
    DuplicateArgument,
    EmptySymbol,
    OddHash,
    SingletonLiteral,
    DynamicConst,
    ConstReassignment,
    ModuleInDef,
    ClassInDef,
    UnexpectedPercentStr,
    BlockAndBlockarg,
    MasgnAsCondition,
    BlockGivenToYield,
    InvalidRegexp,
    UselessElse,
    InvalidEncoding,
    InvalidAction,
    Clobbered,
}


impl fmt::Display for Diagnostic {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let arg1 = match self.data { Some(ref str) => str.as_str(), None => "[??]" };
        match self.error {
            Error::UnicodePointTooLarge => write!(f, "invalid Unicode codepoint (too large)"),
            Error::InvalidEscape => write!(f, "invalid escape character syntax"),
            Error::IncompleteEscape => write!(f, "incomplete character syntax"),
            Error::InvalidHexEscape => write!(f, "invalid hex escape"),
            Error::InvalidUnicodeEscape => write!(f, "invalid Unicode escape"),
            Error::UnterminatedUnicode => write!(f, "unterminated Unicode escape"),
            Error::EscapeEof => write!(f, "escape sequence meets end of file"),
            Error::StringEof => write!(f, "unterminated string meets end of file"),
            Error::RegexpOptions => write!(f, "unknown regexp options: {}", arg1),
            Error::CvarName => write!(f, "`{}' is not allowed as a class variable name", arg1),
            Error::IvarName => write!(f, "`{}' is not allowed as an instance variable name", arg1),
            Error::TrailingInNumber => write!(f, "trailing `{}' in number", arg1),
            Error::EmptyNumeric => write!(f, "numeric literal without digits"),
            Error::InvalidOctal => write!(f, "invalid octal digit"),
            Error::NoDotDigitLiteral => write!(f, "no .<digit> floating literal anymore; put 0 before dot"),
            Error::BareBackslash => write!(f, "bare backslash only allowed before newline"),
            Error::Unexpected => write!(f, "unexpected `{}'", arg1),
            Error::EmbeddedDocument => write!(f, "embedded document meets end of file (and they embark on a romantic journey)"),
            Error::InvalidEscapeUse => write!(f, "invalid character syntax; use ?{}", arg1),
            Error::AmbiguousLiteral => write!(f, "ambiguous first argument; put parentheses or a space even after the operator"),
            Error::AmbiguousPrefix => write!(f, "`{}' interpreted as argument prefix", arg1),
            Error::NthRefAlias => write!(f, "cannot define an alias for a back-reference variable"),
            Error::BeginInMethod => write!(f, "BEGIN in method"),
            Error::BackrefAssignment => write!(f, "cannot assign to a back-reference variable"),
            Error::InvalidAssignment => write!(f, "cannot assign to a keyword"),
            Error::ModuleNameConst => write!(f, "class or module name must be a constant literal"),
            Error::UnexpectedToken => write!(f, "unexpected token: {}", arg1),
            Error::ArgumentConst => write!(f, "formal argument cannot be a constant"),
            Error::ArgumentIvar => write!(f, "formal argument cannot be an instance variable"),
            Error::ArgumentGvar => write!(f, "formal argument cannot be a global variable"),
            Error::ArgumentCvar => write!(f, "formal argument cannot be a class variable"),
            Error::DuplicateArgument => write!(f, "duplicate argument name"),
            Error::EmptySymbol => write!(f, "empty symbol literal"),
            Error::OddHash => write!(f, "odd number of entries for a hash"),
            Error::SingletonLiteral => write!(f, "cannot define a singleton method for a literal"),
            Error::DynamicConst => write!(f, "dynamic constant assignment"),
            Error::ConstReassignment => write!(f, "constant re-assignment"),
            Error::ModuleInDef => write!(f, "module definition in method body"),
            Error::ClassInDef => write!(f, "class definition in method body"),
            Error::UnexpectedPercentStr => write!(f, "{}: unknown type of percent-literal", arg1),
            Error::BlockAndBlockarg => write!(f, "both block argument and literal block are passed"),
            Error::MasgnAsCondition => write!(f, "multiple assignment in conditional context"),
            Error::BlockGivenToYield => write!(f, "block given to yield"),
            Error::InvalidRegexp => write!(f, "{}", arg1),
            Error::UselessElse => write!(f, "else without rescue is useless"),
            Error::InvalidEncoding => write!(f, "literal contains escape sequences incompatible with UTF-8"),
            Error::InvalidAction => write!(f, "cannot {}", arg1),
            Error::Clobbered => write!(f, "clobbered by: {}", arg1),
        }
    }
}
